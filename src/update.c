/*
 * update.c - cve-check-tool
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <utime.h>
#include <errno.h>
#include <glib.h>
#include <gio/gio.h>
#include <curl/curl.h>

#include "cve-check-tool.h"

#include "util.h"
#include "config.h"
#include "cve-string.h"
#include "cve-db-lock.h"
#include "core.h"

#include "update.h"

#define YEAR_START 2002
#define URI_PREFIX "http://static.nvd.nist.gov/feeds/xml/cve"
#include "fetch.h"

#define UPDATE_DB_FNAME_SUFFIX     "cve.update_db.ts"
#define UPDATE_THRESHOLD 7200

gchar *get_db_path(const gchar *path)
{
        const mode_t mode = S_IRWXU|S_IRWXG|S_IRWXO;
        gchar *dir, *ret = NULL;

        if (!path || !*path) {
                const gchar *home = g_get_home_dir();
                dir = g_build_path(G_DIR_SEPARATOR_S, home, nvd_dir, NULL);
        } else {
                dir = (gchar *) path;
        }

        if (mkdir(dir, mode)) {
                struct stat st = { .st_ino = 0, };

                if (errno != EEXIST)
                        goto end;

                if (stat(dir, &st) || !S_ISDIR(st.st_mode))
                        goto end;
        }

        ret = g_build_path(G_DIR_SEPARATOR_S, dir, nvd_file, NULL);
end:
        if (dir != path)
                g_free(dir);
        return ret;
}

static bool __update_required(const gchar *db_file, const gchar *update_fname)
{
        struct stat st;
        time_t t;

        memset(&st, 0, sizeof(st));
        if (stat(db_file, &st))
                goto end;

        if (!st.st_size)
                goto unlink;

        t = time(NULL);
        if (difftime(t, st.st_mtime) >= UPDATE_THRESHOLD)
                goto end;

        memset(&st, 0, sizeof(st));
        if (!stat(update_fname, &st))
                goto unlink;

        return false;
unlink:
        /* Database partial load: unlink it to load again */
        unlink(db_file);
end:
        return true;
}

int update_required(const gchar *db_file)
{
        autofree(char) *u_fname = NULL;

        u_fname = get_db_dot_fname(db_file, UPDATE_DB_FNAME_SUFFIX);
        if (!u_fname)
                return -1;

        return __update_required(db_file, u_fname);
}

#ifndef O_NOFOLLOW
#define O_NOFOLLOW      0
#endif

static inline int update_begin(const char *update_fname)
{
        const int flags = O_RDONLY|O_CREAT|O_NONBLOCK|O_NOFOLLOW;
        const mode_t mode = S_IRUSR|S_IWUSR;

        return open(update_fname, flags, mode);
}

static inline void update_end(int fd, const char *update_fname, bool ok)
{
        close(fd);
        if (ok)
                unlink(update_fname);
}

int update_required(const gchar *db_file)
{
        return __update_required(db_file);
}

bool update_db(bool quiet, const gchar *db_file)
{
        const gchar *nvd_uri = URI_PREFIX;
        autofree(gchar) *db_dir = NULL;
        autofree(CveDB) *cve_db = NULL;
        autofree(GDateTime) *date = NULL;
        autofree(char) *u_fname = NULL;
        int u_handle = -1;
        int year;
        bool ret = false;
        bool db_exist = false;
        bool db_locked = false;

        u_fname = get_db_dot_fname(db_file, UPDATE_DB_FNAME_SUFFIX);
        if (!u_fname)
                goto oom;

        db_dir = g_path_get_dirname(db_file);
        if (!db_dir)
                goto oom;

        db_locked = cve_db_write_lock(LOCK_WAIT_SECS);
        if (!db_locked) {
                fputs("Exiting...\n", stderr);
                goto end;
        }

        /* Lock aquired, check if database is still needs update */
        if (!__update_required(db_file, u_fname)) {
                ret = true;
                goto end;
        }

        u_handle = update_begin(u_fname);
        if (u_handle == -1) {
                fprintf(stderr, "Can't create timestamp file %s\n", u_fname);
                goto end;
        }

        db_exist = cve_file_exists(db_file);

        cve_db = cve_db_new(db_file);
        if (!cve_db) {
                fprintf(stderr, "main(): DB initialisation issue\n");
                goto end;
        }

        date = g_date_time_new_now_local();
        year = g_date_time_get_year(date);

        for (int i = YEAR_START; i <= year+1; i++) {
                autofree(gchar) *uri = NULL;
                autofree(gchar) *target = NULL;
                FetchStatus st;
                bool update = false;
                gchar _nvdcve[sizeof("nvdcve-2.0-YYYY.xml.gz")];
                const gchar *nvdcve;

                if (i > year) {
                        nvdcve = "nvdcve-2.0-Modified.xml.gz";
                } else {
                        g_snprintf(_nvdcve, sizeof(_nvdcve), "nvdcve-2.0-%d.xml.gz", i);
                        nvdcve = _nvdcve;
                }

                uri = g_strdup_printf("%s/%s", nvd_uri, nvdcve);
                if (!uri)
                        goto oom;

                target = g_build_path(G_DIR_SEPARATOR_S, db_dir, nvdcve, NULL);
                if (!target)
                        goto oom;

                st = fetch_uri(uri, target, !quiet);
                switch (st) {
                        case FETCH_STATUS_FAIL:
                                fprintf(stderr, "Failed to fetch %s\n", uri);
                                goto end;
                        case FETCH_STATUS_UPDATE:
                                update = true;
                                break;
                        default:
                                if (!quiet) {
                                        fprintf(stderr, "Skipping: %s\n", basename(target));
                                }
                                break;
                }
                if (update || !db_exist) {
                        /* Only load on updates */
                        if (!gunzip_file(target)) {
                                fprintf(stderr, "Unable to extract %s\n", target);
                                goto end;
                        }
                        if (!cve_db_load(cve_db, target)) {
                                fprintf(stderr, "\nUnable to find: %s\n", target);
                                goto end;
                        }
                        if (!quiet) {
                                fprintf(stderr, "Loaded: %s\n", basename(target));
                        }
                }
        }

        /* Make sure we always update access and modify time on
         * database file, even if no new data loaded.
         */
        if (utime(db_file, NULL)) {
                fprintf(stderr, "Unable to update file access and modify time\n");
                goto end;
        }

        ret = true;
end:
        if (u_handle != -1)
                update_end(u_handle, u_fname, ret);
        if (db_locked)
                cve_db_unlock();
        return ret;
oom:
        fputs("main(): Out of memory\n", stderr);
        goto end;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
