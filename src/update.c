/*
 * update.c - cve-check-tool
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <utime.h>
#include <errno.h>
#include <glib.h>
#include <gio/gio.h>
#include <curl/curl.h>

#include "cve-check-tool.h"

#include "util.h"
#include "config.h"
#include "cve-string.h"
#include "cve-db-lock.h"
#include "core.h"

#include "update.h"

#define YEAR_START 2002
#define URI_PREFIX "http://static.nvd.nist.gov/feeds/xml/cve"
#include "fetch.h"

#define UPDATE_DB_FNAME_SUFFIX     "cve.update_db.ts"
#define UPDATE_THRESHOLD 7200

typedef struct {
        void *mmap;
        off_t length;
        int fd;
} ndi_t;

static void nvdcve_data_fini(ndi_t *ndi);
DEF_AUTOFREE(ndi_t, nvdcve_data_fini)

gchar *get_db_path(const gchar *path)
{
        const mode_t mode = S_IRWXU|S_IRWXG|S_IRWXO;
        gchar *dir, *ret = NULL;

        if (!path || !*path) {
                const gchar *home = g_get_home_dir();
                dir = g_build_path(G_DIR_SEPARATOR_S, home, nvd_dir, NULL);
        } else {
                dir = (gchar *) path;
        }

        if (mkdir(dir, mode)) {
                struct stat st = { .st_ino = 0, };

                if (errno != EEXIST)
                        goto end;

                if (stat(dir, &st) || !S_ISDIR(st.st_mode))
                        goto end;
        }

        ret = g_build_path(G_DIR_SEPARATOR_S, dir, nvd_file, NULL);
end:
        if (dir != path)
                g_free(dir);
        return ret;
}

static gchar *nvdcve_get_fname(int year, const gchar *fext)
{
        if (year == -1)
                return g_strdup_printf("nvdcve-2.0-Modified.%s", fext);
        else
                return g_strdup_printf("nvdcve-2.0-%d.%s", year, fext);
}

/* Returning NULL does not mean that @p_fname parameter is NULL too:
 * either declare variable whose address supplied in @p_fname as autofree()
 * or use g_free() explicitely.
 */
static gchar *__nvdcve_get_pname(int year, const gchar *db_dir,
                                 const gchar *fext, gchar **p_fname)
{
        *p_fname = nvdcve_get_fname(year, fext);
        if (!*p_fname)
                return NULL;
        return g_build_path(G_DIR_SEPARATOR_S, db_dir, *p_fname, NULL);
}

static gchar *nvdcve_get_pname(int year, const gchar *db_dir, const gchar *fext)
{
        autofree(gchar) *fname = NULL;
        return __nvdcve_get_pname(year, db_dir, fext, &fname);
}

static inline FILE *nvdcve_meta_open(const char *f_name)
{
        return fopen(f_name, "r");
}

static inline void nvdcve_meta_close(FILE *f)
{
        fclose(f);
}

static char *nvdcve_meta_get_val(FILE *f, const char *field)
{
        do {
                char field_name[256], field_value[256];
                int ret;

                ret = fscanf(f, " %255[^: \f\n\r\t\v] :%255s",
                             field_name, field_value);
                if (ret != 2) {
                        if (ret != EOF)
                                continue;
                        if (ferror(f)) {
                                if (errno == EINTR || errno == EAGAIN) {
                                        clearerr(f);
                                        continue;
                                }
                        }
                        return NULL;
                }
                if (!strcmp(field_name, field))
                        return strdup(field_value);
        } while (1);
}

static ndi_t *nvdcve_data_init_read(const gchar *f_path)
{
        ndi_t *ndi;
        struct stat sb;

        ndi = calloc(1, sizeof(*ndi));
        if (!ndi)
                goto err_fini;

        ndi->fd = open(f_path, O_RDONLY);
        if (ndi->fd == -1)
                goto err_fini;

        memset(&sb, 0, sizeof(sb));
        if (fstat(ndi->fd, &sb))
                goto err_fini;
        ndi->length = sb.st_size;

        ndi->mmap = mmap(NULL, ndi->length, PROT_READ, MAP_PRIVATE, ndi->fd, 0);
        if (!ndi->mmap)
                goto err_fini;

        return ndi;

err_fini:
        nvdcve_data_fini(ndi);
        return NULL;
}

static void nvdcve_data_fini(ndi_t *ndi)
{
        if (ndi) {
                if (ndi->mmap)
                        munmap(ndi->mmap, ndi->length);
                if (ndi->fd != -1)
                        close(ndi->fd);
                free(ndi);
        }
}

static void nvdcve_unlink(const gchar *nvdcve_meta, const gchar *nvdcve_data)
{
        autofree(gchar) *nvdcve_data_gz = NULL;

        unlink(nvdcve_meta);
        unlink(nvdcve_data);

        nvdcve_data_gz = g_build_path("", nvdcve_data, ".gz", NULL);
        if (nvdcve_data_gz)
                unlink(nvdcve_data_gz);
}

static bool nvdcve_data_ok(int year, const gchar *db_dir)
{
        autofree(ndi_t) *ndi = NULL;
        autofree(gchar) *nvdcve_meta = NULL;
        autofree(gchar) *nvdcve_data = NULL;
        autofree(char) *csum_reference = NULL;
        autofree(gchar) *csum_result = NULL;
        FILE *nvdcve_meta_file;

        nvdcve_meta = nvdcve_get_pname(year, db_dir, "meta");
        if (!nvdcve_meta)
                return false;

        nvdcve_meta_file = nvdcve_meta_open(nvdcve_meta);
        if (!nvdcve_meta_file)
                return false;

        csum_reference = nvdcve_meta_get_val(nvdcve_meta_file, "sha256");

        nvdcve_meta_close(nvdcve_meta_file);

        if (!csum_reference)
                return false;

        nvdcve_data = nvdcve_get_pname(year, db_dir, "xml");
        if (!nvdcve_data)
                return false;

        ndi = nvdcve_data_init_read(nvdcve_data);
        if (!ndi)
                return false;

        csum_result = g_compute_checksum_for_data(G_CHECKSUM_SHA256,
                                                  ndi->mmap, ndi->length);
        if (!csum_result)
                return false;

        if (strcmp(csum_result, csum_reference))
                return false;

        return true;
}

static bool __update_required(const gchar *db_file, const gchar *db_dir,
                              const gchar *update_fname)
{
        struct stat st;
        time_t t;

        memset(&st, 0, sizeof(st));
        if (stat(db_file, &st))
                goto end;

        if (!st.st_size)
                goto unlink;

        t = time(NULL);
        if (difftime(t, st.st_mtime) >= UPDATE_THRESHOLD)
                goto end;

        memset(&st, 0, sizeof(st));
        if (!stat(update_fname, &st))
                goto unlink;

        return false;
unlink:
        /* Database partial load: unlink it to load again */
        unlink(db_file);
end:
        return true;
}

int update_required(const gchar *db_file)
{
        autofree(gchar) *db_dir = NULL;
        autofree(char) *u_fname = NULL;

        u_fname = get_db_dot_fname(db_file, UPDATE_DB_FNAME_SUFFIX);
        if (!u_fname)
                return -1;

        db_dir = g_path_get_dirname(db_file);
        if (!db_dir)
                return -1;

        return __update_required(db_file, db_dir, u_fname);
}

#ifndef O_NOFOLLOW
#define O_NOFOLLOW      0
#endif

static inline int update_begin(const char *update_fname)
{
        const int flags = O_RDONLY|O_CREAT|O_NONBLOCK|O_NOFOLLOW;
        const mode_t mode = S_IRUSR|S_IWUSR;

        return open(update_fname, flags, mode);
}

static inline void update_end(int fd, const char *update_fname, bool ok)
{
        close(fd);
        if (ok)
                unlink(update_fname);
}

static int do_fetch_update(int year, const gchar *db_dir, CveDB *cve_db,
                           bool db_exist, bool verbose)
{
        const gchar *nvd_uri = URI_PREFIX;
        autofree(gchar) *uri_meta = NULL;
        autofree(gchar) *uri_data = NULL;
        autofree(gchar) *nvdcve_meta = NULL;
        autofree(gchar) *nvdcve_data = NULL;
        autofree(gchar) *nvd_xml_gz = NULL;
        autofree(gchar) *nvd_meta = NULL;
        FetchStatus st;
        bool update, load, refetched = false;

        /* Prepare NVD META file/uri pathes */
        nvdcve_meta = __nvdcve_get_pname(year, db_dir, "meta", &nvd_meta);
        if (!nvdcve_meta)
                return ENOMEM;

        uri_meta = g_strdup_printf("%s/%s", nvd_uri, nvd_meta);
        if (!uri_meta)
                return ENOMEM;

        /* Prepare NVD XML file/uri pathes */
        nvdcve_data = __nvdcve_get_pname(year, db_dir, "xml.gz", &nvd_xml_gz);
        if (!nvdcve_data)
                return ENOMEM;

        uri_data = g_strdup_printf("%s/%s", nvd_uri, nvd_xml_gz);
        if (!uri_data)
                return ENOMEM;

refetch:
        if (refetched)
                nvdcve_unlink(nvdcve_meta, nvdcve_data);

        /* Fetch NVD META file */
        st = fetch_uri(uri_meta, nvdcve_meta, verbose);
        if (st == FETCH_STATUS_FAIL) {
                fprintf(stderr, "Failed to fetch %s\n", uri_meta);
                return -1;
        }

        /* Fetch NVD XML file */
        st = fetch_uri(uri_data, nvdcve_data, verbose);
        switch (st) {
        case FETCH_STATUS_FAIL:
                fprintf(stderr, "Failed to fetch %s\n", uri_data);
                return -1;
        case FETCH_STATUS_UPDATE:
                update = load = true;
                break;
        default:
                update = !nvdcve_data_ok(year, db_dir);
                load = !db_exist;
                break;
        }

        if (update) {
                if (!gunzip_file(nvdcve_data)) {
                        if (!refetched) {
                                refetched = true;
                                goto refetch;
                        }
                        fprintf(stderr, "Unable to extract %s\n", nvdcve_data);
                        return -1;
                }
                if (!nvdcve_data_ok(year, db_dir)) {
                        if (!refetched) {
                                refetched = true;
                                goto refetch;
                        }
                        fprintf(stderr, "Fetched data %s is not consistent\n", nvdcve_data);
                        return -1;
                }
        }

        if (load) {
                if (!cve_db_load(cve_db, nvdcve_data)) {
                        fprintf(stderr, "\nUnable to load: %s\n", nvdcve_data);
                        return -1;
                }
        }

        if (verbose) {
                static const char data_report_msg[][sizeof("Skipp")] = {
                        [false] = "Skipp",
                        [true]  = "Load",
                };
                fprintf(stderr, "%sed: %s\n", data_report_msg[load], nvd_xml_gz);
        }

        return 0;
}

bool update_db(bool quiet, const gchar *db_file)
{
        autofree(gchar) *db_dir = NULL;
        autofree(CveDB) *cve_db = NULL;
        autofree(GDateTime) *date = NULL;
        autofree(char) *u_fname = NULL;
        int u_handle = -1;
        int year;
        bool ret = false;
        bool db_exist = false;
        bool db_locked = false;

        u_fname = get_db_dot_fname(db_file, UPDATE_DB_FNAME_SUFFIX);
        if (!u_fname)
                goto oom;

        db_dir = g_path_get_dirname(db_file);
        if (!db_dir)
                goto oom;

        db_locked = cve_db_write_lock(LOCK_WAIT_SECS);
        if (!db_locked) {
                fputs("Exiting...\n", stderr);
                goto end;
        }

        /* Lock aquired, check if database is still needs update */
        if (!__update_required(db_file, db_dir, u_fname)) {
                ret = true;
                goto end;
        }

        u_handle = update_begin(u_fname);
        if (u_handle == -1) {
                fprintf(stderr, "Can't create timestamp file %s\n", u_fname);
                goto end;
        }

        db_exist = cve_file_exists(db_file);

        cve_db = cve_db_new(db_file);
        if (!cve_db) {
                fprintf(stderr, "main(): DB initialisation issue\n");
                goto end;
        }

        date = g_date_time_new_now_local();
        year = g_date_time_get_year(date);

        for (int i = YEAR_START; i <= year+1; i++) {
                int y = i > year ? -1 : i;
                int rc;

                rc = do_fetch_update(y, db_dir, cve_db, db_exist, !quiet);
                if (rc == ENOMEM)
                        goto oom;
                if (rc)
                        goto end;
        }

        /* Make sure we always update access and modify time on
         * database file, even if no new data loaded.
         */
        if (utime(db_file, NULL)) {
                fprintf(stderr, "Unable to update file access and modify time\n");
                goto end;
        }

        ret = true;
end:
        if (u_handle != -1)
                update_end(u_handle, u_fname, ret);
        if (db_locked)
                cve_db_unlock();
        return ret;
oom:
        fputs("main(): Out of memory\n", stderr);
        goto end;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
