/*
 * main.c - cve-check-tool
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <stdint.h>
#include <glib.h>
#include <gio/gio.h>
#include <curl/curl.h>
#include <sys/stat.h>
#include <errno.h>
#include <libgen.h>

#include "cve-check-tool.h"

#include "eopkg.h"
#include "rpm.h"
#include "pkgbuild.h"
#include "faux.h"
#include "util.h"
#include "plugins/jira/jira.h"
#include "config.h"
#include "cve-string.h"
#include "core.h"

#include "update.h"

#include "plugin-manager.h"


static CveCheckTool *self;
static char *srpm_dir = NULL;

#define DEFAULT_CONFIG_FILE     DEFAULT_PATH    "/cve-check-tool.conf"
#define SITE_CONFIG_FILE        SITE_PATH       "/cve-check-tool.conf"

#define SUPPORTED_TYPES "eopkg, rpm, srpm, pkgbuild, faux"

DEF_AUTOFREE(char, free)

#define streq(x,y) strcmp(x,y) == 0


static void cve_add_package_internal(struct source_package_t *pkg)
{
        GList *issues = NULL, *em = NULL;
        gchar *cur_id = NULL;
        gchar *q = NULL;

        if (!pkg) {
                return;
        }

        if (g_hash_table_contains(self->db, pkg->name)) {
                g_hash_table_remove(self->db, pkg->name);
        }

        if (self->mapping) {
                q = g_hash_table_lookup(self->mapping, pkg->name);
        }
        issues = cve_db_get_issues(self->cve_db, q ? q : pkg->name, pkg->version);
        if (!issues) {
                goto insert;
        }

        for (em = issues; em; em = em->next) {
                cur_id = em->data;

                if (self->is_ignored && self->is_ignored(pkg, (gchar*)cur_id)) {
                        continue;
                }

                if (self->is_patched && self->is_patched(pkg, (gchar*)cur_id)) {
                        if (!g_list_find_custom(pkg->patched, cur_id, (GCompareFunc)strcmp)) {
                                gchar *tmp = g_strdup((const gchar*)cur_id);
                                if (!tmp) {
                                        abort();
                                }
                                pkg->patched = g_list_append(pkg->patched, tmp);
                        }
                } else {
                        if (!g_list_find_custom(pkg->issues, cur_id, (GCompareFunc)strcmp)) {
                                gchar *tmp = g_strdup((const gchar*)cur_id);
                                if (!tmp) {
                                        abort();
                                }
                                pkg->issues = g_list_append(pkg->issues, tmp);
                        }
                }
        }
        g_list_free_full(issues, g_free);
insert:
        g_hash_table_insert(self->db, pkg->name, pkg);
}

/**
 * Load CSV data, "faux" as this is metadata, not generated from scanned source
 * files.
 */
static bool load_faux(const char *path)
{
        FILE *fp = NULL;
        size_t read = -1;
        size_t buf_size = 0;
        char *buf = NULL;
        bool ret = false;
        int line = 1;

        fp = fopen(path, "r");
        if (!fp) {
                fprintf(stderr, "load_faux(): %s\n", strerror(errno));
                goto end;
        }

        while ((read = getline(&buf, &buf_size, fp) > 0)) {
                /* TODO: Use a dedicated CsvParser */
                autofree(gstrv) *strv = NULL;
                struct source_package_t *t = NULL;
                struct FauxData *d = NULL;
                gint len;

                buf = g_strchomp(buf);
                /* Empty line */
                if (streq(buf, "")) {
                        goto next;
                }

                strv = g_strsplit(buf, ",", 4);
                if ((len = g_strv_length(strv)) != 4) {
                        fprintf(stderr, "Line #%d is of incorrect length\n", line);
                        break;
                }

                strv[0] = g_strchomp(strv[0]);
                strv[1] = g_strchomp(strv[1]);
                strv[2] = g_strchomp(strv[2]);
                strv[3] = g_strchomp(strv[3]);

                if (streq(strv[0], "")) {
                        fprintf(stderr, "Line #%d: Package name cannot be empty\n", line);
                        break;
                }
                if (streq(strv[1], "")) {
                        fprintf(stderr, "Line #%d: Package version cannot be empty\n", line);
                        break;
                }

                t = calloc(1, sizeof(struct source_package_t));
                if (!t) {
                        fprintf(stderr, "Out of memory\n");
                        free(buf);
                        exit(-1);
                }

                d = calloc(1, sizeof(struct FauxData));
                if (!d) {
                        fprintf(stderr, "Out of memory\n");
                        free(t);
                        free(buf);
                        exit(-1);
                }

                t->name = g_strdup(strv[0]);
                t->version = g_strdup(strv[1]);
                if (!streq(strv[2], "")) {
                        d->patched = g_strsplit(strv[2], " ", -1);
                }
                if (!streq(strv[3], "")) {
                        d->ignored = g_strsplit(strv[3], " ", -1);
                }
                t->extra = d;

                cve_add_package_internal(t);
next:
                free(buf);
                buf = NULL;
                ++line;
        }
        if (read) {
                free(buf);
                buf = NULL;
        }
end:
        return ret;
}

static void cve_add_package(const char *path)
{
        struct source_package_t *pkg = NULL;

        if (self->examine) {
                pkg = self->examine(path);
        } else {
                /* only possible for faux */
                load_faux(path);
        }
        if (!pkg) {
                return;
        }
        cve_add_package_internal(pkg);
}

static void show_version(void)
{
        const gchar *msg = "\
" PACKAGE " " PACKAGE_VERSION "\n\
Copyright (C) 2015 Intel Corporation\n\
" PACKAGE_NAME " is free software; you can redistribute it and/or modify\n\
it under the terms of the GNU General Public License as published by\n\
the Free Software Foundation; either version 2 of the License, or\n\
(at your option) any later version.";
        fprintf(stderr, "%s\n", msg);
}

static bool hide_patched = false;
static bool show_unaffected = false;
static bool _show_version = false;
static bool skip_update = false;
static gchar *nvds = NULL;
static gchar *forced_type = NULL;
static bool no_html = false;
static bool csv_mode = false;
static char *modified_stamp = NULL;
static bool auto_bug = false;
static gchar *auto_bug_template = NULL;
static gchar *mapping_file = NULL;

static GOptionEntry _entries[] = {
        { "not-patched", 'n', 0, G_OPTION_ARG_NONE, &hide_patched, "Hide patched/addressed CVEs", NULL },
        { "not-affected", 'a', 0, G_OPTION_ARG_NONE, &show_unaffected, "Show unaffected items", NULL },
        { "skip-update", 'u', 0, G_OPTION_ARG_NONE, &skip_update, "Bypass forced updates", NULL },
        { "nvd-dir", 'd', 0, G_OPTION_ARG_STRING, &nvds, "NVD directory in filesystem", NULL },
        { "version", 'v', 0, G_OPTION_ARG_NONE, &_show_version, "Show version", NULL },
        { "type", 't', 0, G_OPTION_ARG_STRING, &forced_type, "Set package type to T", "T" },
        { "no-html", 'N', 0, G_OPTION_ARG_NONE, &no_html, "Disable HTML report", NULL },
        { "modified", 'm', 0, G_OPTION_ARG_STRING, &modified_stamp, "Ignore reports after modification date", "D" },
        { "srpm-dir", 's', 0, G_OPTION_ARG_STRING, &srpm_dir, "Source RPM directory", "S" },
        { "csv", 'c', 0, G_OPTION_ARG_NONE, &csv_mode, "Output CSV formatted data only", NULL },
        { "auto-bug", 'b', 0, G_OPTION_ARG_NONE, &auto_bug, "Enable automatic bug tracking", NULL },
        { "auto-bug-template", 'j', 0, G_OPTION_ARG_STRING, &auto_bug_template, "Path to optional auto-bug json template file", NULL },
        { "mapping", 'M', 0, G_OPTION_ARG_STRING, &mapping_file, "Path to a mapping file", NULL},
        { .short_name = 0 }
};

static bool set_package_type(PackageType type)
{
        switch (type) {
                case PACKAGE_TYPE_EOPKG:
                        self->examine = &eopkg_inspect_pspec;
                        self->is_patched = &eopkg_is_patched;
                        self->is_ignored = &eopkg_is_ignored;
                        self->locate = &eopkg_locate_sources;
                        return true;
                case PACKAGE_TYPE_RPM:
                        self->examine = &rpm_inspect_spec;
                        self->is_patched = &rpm_is_patched;
                        self->is_ignored = &rpm_is_ignored;
                        self->locate = &rpm_locate_sources;
                        return true;
                case PACKAGE_TYPE_SRPM:
                        self->examine = &srpm_examine;
                        self->is_patched = &srpm_is_patched;
                        self->is_ignored = &srpm_is_ignored;
                        self->locate = &srpm_locate_sources;
                        return true;
                case PACKAGE_TYPE_PKGBUILD:
                        self->examine = &pkgbuild_inspect_spec;
                        self->is_patched = &pkgbuild_is_patched;
                        self->locate = &pkgbuild_locate_sources;
                        return true;
                case PACKAGE_TYPE_FAUX:
                        self->is_patched = &faux_is_patched;
                        self->is_ignored = &faux_is_ignored;
                        return true;
                default:
                        return false;
        }
}

/**
 * Helper utility to free the bug struct
 */
__attribute__ ((unused)) static inline void bug_free(void *p)
{
        struct jira_issue_t *t = p;

        if (!t) {
                return;
        }
        g_free(t->key);
        g_free(t->summary);
        g_free(t->description);
        g_free(t->status);
        g_slice_free(struct jira_issue_t, t);
}

static ReportStatus bug_status_open = REPORT_STATUS_OPEN;
static ReportStatus bug_status_closed = REPORT_STATUS_CLOSED;
static ReportStatus bug_status_willnotfix = REPORT_STATUS_CLOSED_WILLNOTFIX;

/**
 * Here is where the bug tracker plugin is called.
 */
static bool track_bugs(const gchar *auto_bug_template)
{
        GList *cves, *cve = NULL;
        GList *packages = NULL, *package = NULL;
        GSList *jira_issues = NULL;
        GHashTable *no_dup_ids = NULL;
        autofree(gchar) *jira_search_json = NULL;
        autofree(gchar) *jira_add_json = NULL;
        autofree(gchar) *cve_url = NULL;
        const GSList *iter = NULL;
        struct cve_entry_t *cve_entry = NULL;
        struct jira_issue_t *jira_issue = NULL;
        bool ret = true;

        if (self == NULL || self->cve_db == NULL) {
                return false;
        }
        /* TODO: Assert database data */
        if (!init_jira_plugin(self->config, NULL)) {
                return false;
        }
        if (!is_jira_alive()) {
                return false;
        }
        if (!build_search_jira_issues(&jira_search_json)) {
                return false;
        }
        if (!get_jira_issues(jira_search_json, &jira_issues)) {
                return false;
        }
        self->bdb = g_hash_table_new(g_str_hash, g_int_equal);
        iter = jira_issues;
        while(iter) {
                jira_issue = iter->data;
                if (g_strcmp0(jira_issue->status, "Closed")) {
                        g_hash_table_insert(self->bdb, g_strdup(jira_issue->summary), &bug_status_open);
                } else {
                        if (!g_hash_table_contains(self->bdb, jira_issue->summary)) {
                                g_hash_table_insert(self->bdb, g_strdup(jira_issue->summary), &bug_status_closed);
                        }
                        if (!g_strcmp0(jira_issue->resolution, "Will Not Fix")) {
                                g_hash_table_insert(self->bdb, g_strdup(jira_issue->summary), &bug_status_willnotfix);
                        }
                }
                iter = iter->next;
        }
        no_dup_ids = g_hash_table_new(g_str_hash, g_str_equal);
        packages = g_hash_table_get_values(self->db);
        for (package = packages; package; package = package->next) {
                struct source_package_t *pkg = packages->data;
                char *q = NULL;
                if (self->mapping) {
                        q = g_hash_table_lookup(self->mapping, pkg->name);
                }
                cves = cve_db_get_issues(self->cve_db, q ? q : pkg->name, pkg->version);
                if (!cves) {
                        continue;
                }
                for (cve = cves; cve; cve = cve->next) {
                        cve_entry = cve->data;
                        jira_issue = get_jira_issue(jira_issues, cve_entry->id);
                        if (!jira_issue && !g_hash_table_contains(no_dup_ids, cve_entry->id)) {
                                cve_url = g_strdup_printf("https://cve.mitre.org/cgi-bin/cvename.cgi?name=%s", cve_entry->id);
                                fprintf(stderr, "Adding to bug database: %s\n -%s\n",
                                cve_entry->id, cve_url);
                                if (auto_bug_template == NULL) {
                                        ret = build_new_jira_issue(cve_entry->id, cve_url, false, &jira_add_json);
                                } else {
                                        ret = build_new_jira_issue_file(cve_entry->id, cve_url, auto_bug_template, &jira_add_json);
                                }
                                if (!ret) {
                                        break;
                                }
                                ret = add_new_jira_issue(jira_add_json);
                                if (!ret) {
                                        break;
                                }
                                g_hash_table_insert(no_dup_ids, cve_entry->id, cve_entry->id);
                                g_hash_table_insert(self->bdb, g_strdup(cve_entry->id), &bug_status_open);
                                cve_entry->status = REPORT_STATUS_OPEN;
                        } else if (jira_issue) {
                                cve_entry->status = *((ReportStatus *)g_hash_table_lookup(self->bdb, jira_issue->summary));
                        }
                }
                g_list_free(cves);
        }
        g_list_free(packages);
        g_hash_table_destroy(no_dup_ids);
        free_jira_issues(&jira_issues);
        if (!ret) {
                fprintf(stderr, "Error: Aborting adding CVEs to bug database due to errors\n");
        }
        destroy_jira_plugin();
        return NULL;
}

/**
 * Main entry.
 */
int main(int argc, char **argv)
{
        autofree(GError) *error = NULL;
        autofree(GOptionContext) *context = NULL;
        autofree(char) *target = NULL;
        autofree(GKeyFile) *config = NULL;
        autofree(gchar) *db_path = NULL;
        autofree(CveDB) *cve_db = NULL;
        int ret = EXIT_FAILURE;
        PackageType type = PACKAGE_TYPE_UNKNOWN;
        CveCheckTool instance = {.is_patched = 0};
        instance.modified = -1;
        time_t ti;
        CvePlugin *report = NULL;
        LIBXML_TEST_VERSION
        bool quiet;

        self = &instance;
        context = g_option_context_new(" - cve check tool");
        g_option_context_add_main_entries(context, _entries, NULL);
        if (!g_option_context_parse(context, &argc, &argv, &error)) {
                g_printerr("Invalid options: %s\n", error->message);
                goto cleanup;
        }

        quiet = csv_mode || !no_html;

        if (_show_version) {
                show_version();
                ret = EXIT_SUCCESS;
                goto cleanup;
        }

        db_path = get_db_path(nvds);
        if (!db_path) {
                fprintf(stderr, "main(): Out of memory\n");
                goto cleanup;
        }

        if (!skip_update) {
                int status = update_required(db_path);
                if (status == -1) {
                        fprintf(stderr, "Failed to check if db requires update\n");
                        goto cleanup;
                }
                if (status) {
                        fprintf(stderr, "Update of db forced\n");
                        if (!update_db(quiet, db_path)) {
                                fprintf(stderr, "DB update failure\n");
                                goto cleanup;
                        }
                }
        } else {
                if (!cve_file_exists(db_path)) {
                        fprintf(stderr, "Not continuing without a database\n");
                        goto cleanup;
                }
        }

        cve_db = cve_db_new(db_path);
        if (!cve_db) {
                fprintf(stderr, "main(): DB initialisation issue\n");
                goto cleanup;
        }

        self->cve_db = cve_db;

        if (forced_type) {
                if (g_str_equal(forced_type, "rpm")) {
                        type = PACKAGE_TYPE_RPM;
                } else if (g_str_equal(forced_type, "srpm")) {
                        type = PACKAGE_TYPE_SRPM;
                } else if (g_str_equal(forced_type, "eopkg")) {
                        type = PACKAGE_TYPE_EOPKG;
                } else if (g_str_equal(forced_type, "pkgbuild")) {
                        type = PACKAGE_TYPE_PKGBUILD;
                } else if (g_str_equal(forced_type, "faux")) {
                        type = PACKAGE_TYPE_FAUX;
                } else if (g_str_equal(forced_type, "list")) {
                        fprintf(stderr, "Currently supported package types: %s\n", SUPPORTED_TYPES);
                        ret = EXIT_SUCCESS;
                        goto cleanup;
                } else {
                        fprintf(stderr, "Unknown type: \"%s\".\nCurrently supported types: %s\n", forced_type, SUPPORTED_TYPES);
                        goto cleanup;
                }
        }

        if (argc != 2) {
                fprintf(stderr, "Usage: %s [path-to-source-spec|path-to-source-list-file]\n", argv[0]);
                goto cleanup;
        }

        if (!cve_file_exists(argv[1])) {
                fprintf(stderr, "%s does not exist\n", argv[1]);
                goto cleanup;
        }

        target = realpath(argv[1], NULL);
        if (!target) {
                goto cleanup;
        }

        if (mapping_file) {
                autofree(GKeyFile) *mp = g_key_file_new();
                autofree(gstrv) *keys = NULL;
                self->mapping = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
                if (!g_key_file_load_from_file(mp, mapping_file, 0, &error)) {
                        fprintf(stderr, "Unable to load mapping file: %s\n", error->message);
                        goto cleanup;
                }
                if (!g_key_file_has_group(mp, "Mapping")) {
                        fprintf(stderr, "Mapping file misses [Mapping] group\n");
                        goto cleanup;
                }
                keys = g_key_file_get_keys(mp, "Mapping", NULL, &error);
                if (!keys) {
                        fprintf(stderr, "Unable to load mapping keys: %s\n", error->message);
                        goto cleanup;
                }
                char **c = keys;
                while (*c) {
                        autofree(gchar) *val = g_key_file_get_string(mp, "Mapping", *c, &error);
                        if (!val) {
                                fprintf(stderr, "Unable to load mapping string: %s\n", error->message);
                                goto cleanup;
                        }
                        /* Reverse the mapping */
                        g_hash_table_insert(self->mapping, g_strdup(val), g_strdup(*c));
                        ++c;
                }
        }
        self->bugs = auto_bug;
        if (srpm_dir) {
                if (!cve_is_dir(srpm_dir)) {
                        fprintf(stderr, "srpm directory does not exist or is not a directory\n");
                        goto cleanup;
                }
                self->is_patched = srpm_is_patched;
                self->is_ignored = srpm_is_ignored;
        }

        if (!forced_type) {
                type = guess_package_type(target, false);
        }

        if (modified_stamp) {
                ti = curl_getdate(modified_stamp, NULL);
                if (ti <= 0) {
                        fprintf(stderr, "Invalid date\n");
                        goto cleanup;
                }
                instance.modified = (int64_t)ti;
        }

        if (auto_bug) {
                if (cve_file_exists(SITE_CONFIG_FILE)) {
                        config = g_key_file_new();
                        if (!g_key_file_load_from_file(config, SITE_CONFIG_FILE, G_KEY_FILE_KEEP_TRANSLATIONS, &error)) {
                                fprintf(stderr, "Unable to read configuration: %s\n", error->message);
                                goto cleanup;
                        }
                } else {
                        fprintf(stderr, "No valid bugs configuration found, aborting\n");
                        goto cleanup;
                }
        }

        self->config = config;
        self->hide_patched = hide_patched;
        self->show_unaffected = show_unaffected;
        instance.db = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, package_free);
        instance.bdb = NULL;

        cve_plugin_manager_init();

        if (type > PACKAGE_TYPE_MIN && type < PACKAGE_TYPE_UNKNOWN) {
                if (!set_package_type(type)) {
                        fprintf(stderr, "Unsupported package type\n");
                        goto cleanup;
                }
                /* Attempt to add a single package.. */
                if (cve_is_dir(target)) {
                        /* Recurse.. */
                        self->locate(target, true, &cve_add_package);
                } else {
                        cve_add_package(target);
                }
        } else if (type == PACKAGE_TYPE_UNKNOWN && is_package_list(target)) {
                /* Packages file */
                ssize_t read = -1;
                size_t buf_size = 0;
                FILE *fp = NULL;
                char *buf = NULL;
                autofree(char) *basedirsz = NULL;

                fp = fopen(target, "r");
                if (!fp) {
                        fprintf(stderr, "Unable to open file for reading: %s\n", strerror(errno));
                        goto cleanup;
                }

                basedirsz = cve_get_file_parent(target);
                if (!basedirsz) {
                        fprintf(stderr, "Error locating file parent: %s\n", target);
                        goto cleanup;
                }

                while ((read = getline(&buf, &buf_size, fp) > 0)) {
                        autofree(char) *path = NULL;
                        buf = g_strchomp(buf);

                        if (streq(buf, "")) {
                                free(buf);
                                buf = NULL;
                                continue;
                        }

                        /* Tab delimited files mean we don't look through git trees */
                        if (str_contains(buf, "\t")) {
                                autofree(gstrv) *splits = g_strsplit(buf, "\t", 3);
                                struct source_package_t *t = NULL;

                                if (srpm_dir) {
                                        t = rpm_inspect_srpm(srpm_dir, splits[0], splits[1], splits[2]);
                                        if (!t) {
                                                goto clean;
                                        }
                                } else {
                                        t = calloc(1, sizeof(struct source_package_t));
                                        if (!t) {
                                                goto clean;
                                        }
                                        t->path = NULL;
                                        t->name = g_strdup(splits[0]);
                                        t->version = g_strdup(splits[1]);
                                }
                                cve_add_package_internal(t);
                                goto clean;
                        }
                        /* try directory above *first* as this is the norm */
                        if (!asprintf(&path, "%s/../%s", basedirsz, buf)) {
                                fprintf(stderr, "main(): Out of memory\n");
                                goto cleanup;
                        }
                        if (!cve_file_exists(path)) {
                                free(path);
                                /* Fall back to building from current directory */
                                if (!asprintf(&path, "%s/%s", basedirsz, buf)) {
                                        fprintf(stderr, "main(): Out of memory\n");
                                        goto cleanup;
                                }
                        }
                        if (!cve_file_exists(path)) {
                                fprintf(stderr, "Warning: Not found: %s\n", path);
                                goto clean;
                        }

                        /* Attempt to determine type.. */
                        if (type == PACKAGE_TYPE_UNKNOWN) {
                                type = guess_package_type(path, true);
                                if (type == PACKAGE_TYPE_UNKNOWN) {
                                        fprintf(stderr, "Unable to determine package type, bailing\n");
                                        free(buf);
                                        goto cleanup;
                                }
                                if (!set_package_type(type)) {
                                        fprintf(stderr, "Unsupported package type\n");
                                        free(buf);
                                        goto cleanup;
                                }
                        }
                        self->locate(path, false, &cve_add_package);
clean:
                        free(buf);
                        buf = NULL;
                }
                if (buf) {
                        free(buf);
                        buf = NULL;
                }

        } else {
                fprintf(stderr, "Unsupported file: %s\n", target);
                goto cleanup;
        }

        gint size = g_hash_table_size(self->db);
        if (size == 0) {
                fprintf(stderr, "No source files were encountered, aborting\n");
                goto cleanup;
        }
        /* Consider a verbosity flag... */
        if (!quiet) {
                fprintf(stderr, "Scanned %d source file%s\n", size, size > 1 ? "s" : "");
        }

        if (auto_bug) {
                track_bugs(auto_bug_template);
        }

        /* TODO: Switch to single output mode, with a report type set in
         * config and/or flags, i.e. -r html (preserve csv option though)
         */
        if (csv_mode) {
                report = cve_plugin_get_by_name("csv");
        } else if (!no_html) {
                report = cve_plugin_get_by_name("html");
        } else {
                report = cve_plugin_get_by_name("cli");
        }

        if (!report || !report->report) {
                fprintf(stderr, "No usable output module\n");
                goto cleanup;
        }

        if (!report->report(self)) {
                fprintf(stderr, "Report generation failed\n");
                goto cleanup;
        }

        ret = EXIT_SUCCESS;

cleanup:
        cve_plugin_manager_destroy();
        if (instance.db) {
                g_hash_table_unref(instance.db);
        }
        if (self->bdb) {
                g_hash_table_unref(self->bdb);
        }
        if (self->mapping) {
                g_hash_table_unref(self->mapping);
        }
        xmlCleanupParser();
        return ret;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */

